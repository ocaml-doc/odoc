\section{Module \ocamlinlinecode{Type}}\label{container-page-test+u+package+++ml-module-Type}%
\label{container-page-test+u+package+++ml-module-Type-type-abstract}\ocamlcodefragment{\ocamltag{keyword}{type} abstract}\begin{ocamlindent}Some \emph{documentation}.\end{ocamlindent}%
\medbreak
\label{container-page-test+u+package+++ml-module-Type-type-alias}\ocamlcodefragment{\ocamltag{keyword}{type} alias = int}\\
\label{container-page-test+u+package+++ml-module-Type-type-private+u+}\ocamlcodefragment{\ocamltag{keyword}{type} private\_\allowbreak{} = \ocamltag{keyword}{private} int}\\
\label{container-page-test+u+package+++ml-module-Type-type-constructor}\ocamlcodefragment{\ocamltag{keyword}{type} 'a constructor = \ocamltag{type-var}{'a}}\\
\label{container-page-test+u+package+++ml-module-Type-type-arrow}\ocamlcodefragment{\ocamltag{keyword}{type} arrow = int \ocamltag{arrow}{$\rightarrow$} int}\\
\label{container-page-test+u+package+++ml-module-Type-type-higher+u+order}\ocamlcodefragment{\ocamltag{keyword}{type} higher\_\allowbreak{}order = (int \ocamltag{arrow}{$\rightarrow$} int) \ocamltag{arrow}{$\rightarrow$} int}\\
\label{container-page-test+u+package+++ml-module-Type-type-labeled}\ocamlcodefragment{\ocamltag{keyword}{type} labeled = l:int \ocamltag{arrow}{$\rightarrow$} int}\\
\label{container-page-test+u+package+++ml-module-Type-type-optional}\ocamlcodefragment{\ocamltag{keyword}{type} optional = ?l:int \ocamltag{arrow}{$\rightarrow$} int}\\
\label{container-page-test+u+package+++ml-module-Type-type-labeled+u+higher+u+order}\ocamlcodefragment{\ocamltag{keyword}{type} labeled\_\allowbreak{}higher\_\allowbreak{}order = (l:int \ocamltag{arrow}{$\rightarrow$} int) \ocamltag{arrow}{$\rightarrow$} (?l:int \ocamltag{arrow}{$\rightarrow$} int) \ocamltag{arrow}{$\rightarrow$} int}\\
\label{container-page-test+u+package+++ml-module-Type-type-pair}\ocamlcodefragment{\ocamltag{keyword}{type} pair = int * int}\\
\label{container-page-test+u+package+++ml-module-Type-type-parens+u+dropped}\ocamlcodefragment{\ocamltag{keyword}{type} parens\_\allowbreak{}dropped = int * int}\\
\label{container-page-test+u+package+++ml-module-Type-type-triple}\ocamlcodefragment{\ocamltag{keyword}{type} triple = int * int * int}\\
\label{container-page-test+u+package+++ml-module-Type-type-nested+u+pair}\ocamlcodefragment{\ocamltag{keyword}{type} nested\_\allowbreak{}pair = (int * int) * int}\\
\label{container-page-test+u+package+++ml-module-Type-type-instance}\ocamlcodefragment{\ocamltag{keyword}{type} instance = int \hyperref[container-page-test+u+package+++ml-module-Type-type-constructor]{\ocamlinlinecode{constructor}}}\\
\label{container-page-test+u+package+++ml-module-Type-type-long}\ocamlcodefragment{\ocamltag{keyword}{type} long = \hyperref[container-page-test+u+package+++ml-module-Type-type-labeled+u+higher+u+order]{\ocamlinlinecode{labeled\_\allowbreak{}higher\_\allowbreak{}order}} \ocamltag{arrow}{$\rightarrow$} [ `Bar | `Baz of \hyperref[container-page-test+u+package+++ml-module-Type-type-triple]{\ocamlinlinecode{triple}} ] \ocamltag{arrow}{$\rightarrow$} \hyperref[container-page-test+u+package+++ml-module-Type-type-pair]{\ocamlinlinecode{pair}} \ocamltag{arrow}{$\rightarrow$} \hyperref[container-page-test+u+package+++ml-module-Type-type-labeled]{\ocamlinlinecode{labeled}} \ocamltag{arrow}{$\rightarrow$} \hyperref[container-page-test+u+package+++ml-module-Type-type-higher+u+order]{\ocamlinlinecode{higher\_\allowbreak{}order}} \ocamltag{arrow}{$\rightarrow$} (string \ocamltag{arrow}{$\rightarrow$} int) \ocamltag{arrow}{$\rightarrow$} (int,\allowbreak{} float,\allowbreak{} char,\allowbreak{} string,\allowbreak{} char,\allowbreak{} unit) \hyperref[xref-unresolved]{\ocamlinlinecode{CamlinternalFormatBasics}}.\allowbreak{}fmtty \ocamltag{arrow}{$\rightarrow$} \hyperref[container-page-test+u+package+++ml-module-Type-type-nested+u+pair]{\ocamlinlinecode{nested\_\allowbreak{}pair}} \ocamltag{arrow}{$\rightarrow$} \hyperref[container-page-test+u+package+++ml-module-Type-type-arrow]{\ocamlinlinecode{arrow}} \ocamltag{arrow}{$\rightarrow$} string \ocamltag{arrow}{$\rightarrow$} \hyperref[container-page-test+u+package+++ml-module-Type-type-nested+u+pair]{\ocamlinlinecode{nested\_\allowbreak{}pair}} array}\\
\label{container-page-test+u+package+++ml-module-Type-type-variant+u+e}\ocamlcodefragment{\ocamltag{keyword}{type} variant\_\allowbreak{}e = \{}\\
\begin{ocamltabular}{p{1.000\textwidth}}\ocamlinlinecode{a : int;\allowbreak{}}\label{container-page-test+u+package+++ml-module-Type-type-variant+u+e.a}\\
\end{ocamltabular}%
\\
\ocamlcodefragment{\}}\\
\label{container-page-test+u+package+++ml-module-Type-type-variant}\ocamlcodefragment{\ocamltag{keyword}{type} variant = }\\
\begin{ocamltabular}{p{0.500\textwidth}p{0.500\textwidth}}\ocamlcodefragment{| \ocamltag{constructor}{A}}\label{container-page-test+u+package+++ml-module-Type-type-variant.A}& \\
\ocamlcodefragment{| \ocamltag{constructor}{B} \ocamltag{keyword}{of} int}\label{container-page-test+u+package+++ml-module-Type-type-variant.B}& \\
\ocamlcodefragment{| \ocamltag{constructor}{C}}\label{container-page-test+u+package+++ml-module-Type-type-variant.C}& foo\\
\ocamlcodefragment{| \ocamltag{constructor}{D}}\label{container-page-test+u+package+++ml-module-Type-type-variant.D}& \emph{bar}\\
\ocamlcodefragment{| \ocamltag{constructor}{E} \ocamltag{keyword}{of} \hyperref[container-page-test+u+package+++ml-module-Type-type-variant+u+e]{\ocamlinlinecode{variant\_\allowbreak{}e}}}\label{container-page-test+u+package+++ml-module-Type-type-variant.E}& \\
\end{ocamltabular}%
\\
\label{container-page-test+u+package+++ml-module-Type-type-variant+u+c}\ocamlcodefragment{\ocamltag{keyword}{type} variant\_\allowbreak{}c = \{}\\
\begin{ocamltabular}{p{1.000\textwidth}}\ocamlinlinecode{a : int;\allowbreak{}}\label{container-page-test+u+package+++ml-module-Type-type-variant+u+c.a}\\
\end{ocamltabular}%
\\
\ocamlcodefragment{\}}\\
\label{container-page-test+u+package+++ml-module-Type-type-gadt}\ocamlcodefragment{\ocamltag{keyword}{type} \_\allowbreak{} gadt = }\\
\begin{ocamltabular}{p{1.000\textwidth}}\ocamlcodefragment{| \ocamltag{constructor}{A} : int \hyperref[container-page-test+u+package+++ml-module-Type-type-gadt]{\ocamlinlinecode{gadt}}}\label{container-page-test+u+package+++ml-module-Type-type-gadt.A}\\
\ocamlcodefragment{| \ocamltag{constructor}{B} : int \ocamltag{arrow}{$\rightarrow$} string \hyperref[container-page-test+u+package+++ml-module-Type-type-gadt]{\ocamlinlinecode{gadt}}}\label{container-page-test+u+package+++ml-module-Type-type-gadt.B}\\
\ocamlcodefragment{| \ocamltag{constructor}{C} : \hyperref[container-page-test+u+package+++ml-module-Type-type-variant+u+c]{\ocamlinlinecode{variant\_\allowbreak{}c}} \ocamltag{arrow}{$\rightarrow$} unit \hyperref[container-page-test+u+package+++ml-module-Type-type-gadt]{\ocamlinlinecode{gadt}}}\label{container-page-test+u+package+++ml-module-Type-type-gadt.C}\\
\end{ocamltabular}%
\\
\label{container-page-test+u+package+++ml-module-Type-type-degenerate+u+gadt}\ocamlcodefragment{\ocamltag{keyword}{type} degenerate\_\allowbreak{}gadt = }\\
\begin{ocamltabular}{p{1.000\textwidth}}\ocamlcodefragment{| \ocamltag{constructor}{A} : \hyperref[container-page-test+u+package+++ml-module-Type-type-degenerate+u+gadt]{\ocamlinlinecode{degenerate\_\allowbreak{}gadt}}}\label{container-page-test+u+package+++ml-module-Type-type-degenerate+u+gadt.A}\\
\end{ocamltabular}%
\\
\label{container-page-test+u+package+++ml-module-Type-type-private+u+variant}\ocamlcodefragment{\ocamltag{keyword}{type} private\_\allowbreak{}variant = \ocamltag{keyword}{private} }\\
\begin{ocamltabular}{p{1.000\textwidth}}\ocamlcodefragment{| \ocamltag{constructor}{A}}\label{container-page-test+u+package+++ml-module-Type-type-private+u+variant.A}\\
\end{ocamltabular}%
\\
\label{container-page-test+u+package+++ml-module-Type-type-record}\ocamlcodefragment{\ocamltag{keyword}{type} record = \{}\\
\begin{ocamltabular}{p{0.500\textwidth}p{0.500\textwidth}}\ocamlinlinecode{a : int;\allowbreak{}}\label{container-page-test+u+package+++ml-module-Type-type-record.a}& \\
\ocamlinlinecode{\ocamltag{keyword}{mutable} b : int;\allowbreak{}}\label{container-page-test+u+package+++ml-module-Type-type-record.b}& \\
\ocamlinlinecode{c : int;\allowbreak{}}\label{container-page-test+u+package+++ml-module-Type-type-record.c}& foo\\
\ocamlinlinecode{d : int;\allowbreak{}}\label{container-page-test+u+package+++ml-module-Type-type-record.d}& \emph{bar}\\
\ocamlinlinecode{e : a.\allowbreak{} \ocamltag{type-var}{'a};\allowbreak{}}\label{container-page-test+u+package+++ml-module-Type-type-record.e}& \\
\end{ocamltabular}%
\\
\ocamlcodefragment{\}}\\
\label{container-page-test+u+package+++ml-module-Type-type-polymorphic+u+variant}\ocamlcodefragment{\ocamltag{keyword}{type} polymorphic\_\allowbreak{}variant = [ }\\
\begin{ocamltabular}{p{1.000\textwidth}}\ocamlinlinecode{| }\ocamlinlinecode{`A}\label{container-page-test+u+package+++ml-module-Type-type-polymorphic+u+variant.A}\\
\ocamlinlinecode{| }\ocamlinlinecode{`B \ocamltag{keyword}{of} int}\label{container-page-test+u+package+++ml-module-Type-type-polymorphic+u+variant.B}\\
\ocamlinlinecode{| }\ocamlinlinecode{`C \ocamltag{keyword}{of} int * unit}\label{container-page-test+u+package+++ml-module-Type-type-polymorphic+u+variant.C}\\
\ocamlinlinecode{| }\ocamlinlinecode{`D}\label{container-page-test+u+package+++ml-module-Type-type-polymorphic+u+variant.D}\\
\end{ocamltabular}%
\\
\ocamlcodefragment{ ]}\\
\label{container-page-test+u+package+++ml-module-Type-type-polymorphic+u+variant+u+extension}\ocamlcodefragment{\ocamltag{keyword}{type} polymorphic\_\allowbreak{}variant\_\allowbreak{}extension = [ }\\
\begin{ocamltabular}{p{1.000\textwidth}}\ocamlinlinecode{| }\ocamlinlinecode{\hyperref[container-page-test+u+package+++ml-module-Type-type-polymorphic+u+variant]{\ocamlinlinecode{polymorphic\_\allowbreak{}variant}}}\label{container-page-test+u+package+++ml-module-Type-type-polymorphic+u+variant+u+extension.polymorphic+u+variant}\\
\ocamlinlinecode{| }\ocamlinlinecode{`E}\label{container-page-test+u+package+++ml-module-Type-type-polymorphic+u+variant+u+extension.E}\\
\end{ocamltabular}%
\\
\ocamlcodefragment{ ]}\\
\label{container-page-test+u+package+++ml-module-Type-type-nested+u+polymorphic+u+variant}\ocamlcodefragment{\ocamltag{keyword}{type} nested\_\allowbreak{}polymorphic\_\allowbreak{}variant = [ }\\
\begin{ocamltabular}{p{1.000\textwidth}}\ocamlinlinecode{| }\ocamlinlinecode{`A \ocamltag{keyword}{of} [ `B | `C ]}\label{container-page-test+u+package+++ml-module-Type-type-nested+u+polymorphic+u+variant.A}\\
\end{ocamltabular}%
\\
\ocamlcodefragment{ ]}\\
\label{container-page-test+u+package+++ml-module-Type-type-private+u+extenion#row}\ocamlcodefragment{\ocamltag{keyword}{type} private\_\allowbreak{}extenion\#row}\\
\label{container-page-test+u+package+++ml-module-Type-type-private+u+extenion}\ocamlcodefragment{\ocamltag{keyword}{and} private\_\allowbreak{}extenion = \ocamltag{keyword}{private} [> }\\
\begin{ocamltabular}{p{1.000\textwidth}}\ocamlinlinecode{| }\ocamlinlinecode{\hyperref[container-page-test+u+package+++ml-module-Type-type-polymorphic+u+variant]{\ocamlinlinecode{polymorphic\_\allowbreak{}variant}}}\label{container-page-test+u+package+++ml-module-Type-type-private+u+extenion.polymorphic+u+variant}\\
\end{ocamltabular}%
\\
\ocamlcodefragment{ ]}\\
\label{container-page-test+u+package+++ml-module-Type-type-object+u+}\ocamlcodefragment{\ocamltag{keyword}{type} object\_\allowbreak{} = < a : int;\allowbreak{} b : int;\allowbreak{} c : int;\allowbreak{} >}\\
\label{container-page-test+u+package+++ml-module-Type-module-type-X}\ocamlcodefragment{\ocamltag{keyword}{module} \ocamltag{keyword}{type} \hyperref[container-page-test+u+package+++ml-module-Type-module-type-X]{\ocamlinlinecode{X}}}\ocamlcodefragment{ = \ocamltag{keyword}{sig}}\begin{ocamlindent}\label{container-page-test+u+package+++ml-module-Type-module-type-X-type-t}\ocamlcodefragment{\ocamltag{keyword}{type} t}\\
\label{container-page-test+u+package+++ml-module-Type-module-type-X-type-u}\ocamlcodefragment{\ocamltag{keyword}{type} u}\\
\end{ocamlindent}%
\ocamlcodefragment{\ocamltag{keyword}{end}}\\
\label{container-page-test+u+package+++ml-module-Type-type-module+u+}\ocamlcodefragment{\ocamltag{keyword}{type} module\_\allowbreak{} = (\ocamltag{keyword}{module} \hyperref[container-page-test+u+package+++ml-module-Type-module-type-X]{\ocamlinlinecode{X}})}\\
\label{container-page-test+u+package+++ml-module-Type-type-module+u+substitution}\ocamlcodefragment{\ocamltag{keyword}{type} module\_\allowbreak{}substitution = (\ocamltag{keyword}{module} \hyperref[container-page-test+u+package+++ml-module-Type-module-type-X]{\ocamlinlinecode{X}} \ocamltag{keyword}{with} \ocamltag{keyword}{type} \hyperref[container-page-test+u+package+++ml-module-Type-module-type-X-type-t]{\ocamlinlinecode{t}} = int \ocamltag{keyword}{and} \ocamltag{keyword}{type} \hyperref[container-page-test+u+package+++ml-module-Type-module-type-X-type-u]{\ocamlinlinecode{u}} = unit)}\\
\label{container-page-test+u+package+++ml-module-Type-type-covariant}\ocamlcodefragment{\ocamltag{keyword}{type} +'a covariant}\\
\label{container-page-test+u+package+++ml-module-Type-type-contravariant}\ocamlcodefragment{\ocamltag{keyword}{type} -'a contravariant}\\
\label{container-page-test+u+package+++ml-module-Type-type-bivariant}\ocamlcodefragment{\ocamltag{keyword}{type} \_\allowbreak{} bivariant = int}\\
\label{container-page-test+u+package+++ml-module-Type-type-binary}\ocamlcodefragment{\ocamltag{keyword}{type} ('a,\allowbreak{} 'b) binary}\\
\label{container-page-test+u+package+++ml-module-Type-type-using+u+binary}\ocamlcodefragment{\ocamltag{keyword}{type} using\_\allowbreak{}binary = (int,\allowbreak{} int) \hyperref[container-page-test+u+package+++ml-module-Type-type-binary]{\ocamlinlinecode{binary}}}\\
\label{container-page-test+u+package+++ml-module-Type-type-name}\ocamlcodefragment{\ocamltag{keyword}{type} 'custom name}\\
\label{container-page-test+u+package+++ml-module-Type-type-constrained}\ocamlcodefragment{\ocamltag{keyword}{type} 'a constrained = \ocamltag{type-var}{'a} \ocamltag{keyword}{constraint} \ocamltag{type-var}{'a} = int}\\
\label{container-page-test+u+package+++ml-module-Type-type-exact+u+variant}\ocamlcodefragment{\ocamltag{keyword}{type} 'a exact\_\allowbreak{}variant = \ocamltag{type-var}{'a} \ocamltag{keyword}{constraint} \ocamltag{type-var}{'a} = [ `A | `B of int ]}\\
\label{container-page-test+u+package+++ml-module-Type-type-lower+u+variant}\ocamlcodefragment{\ocamltag{keyword}{type} 'a lower\_\allowbreak{}variant = \ocamltag{type-var}{'a} \ocamltag{keyword}{constraint} \ocamltag{type-var}{'a} = [> `A | `B of int ]}\\
\label{container-page-test+u+package+++ml-module-Type-type-any+u+variant}\ocamlcodefragment{\ocamltag{keyword}{type} 'a any\_\allowbreak{}variant = \ocamltag{type-var}{'a} \ocamltag{keyword}{constraint} \ocamltag{type-var}{'a} = [>  ]}\\
\label{container-page-test+u+package+++ml-module-Type-type-upper+u+variant}\ocamlcodefragment{\ocamltag{keyword}{type} 'a upper\_\allowbreak{}variant = \ocamltag{type-var}{'a} \ocamltag{keyword}{constraint} \ocamltag{type-var}{'a} = [< `A | `B of int ]}\\
\label{container-page-test+u+package+++ml-module-Type-type-named+u+variant}\ocamlcodefragment{\ocamltag{keyword}{type} 'a named\_\allowbreak{}variant = \ocamltag{type-var}{'a} \ocamltag{keyword}{constraint} \ocamltag{type-var}{'a} = [< \hyperref[container-page-test+u+package+++ml-module-Type-type-polymorphic+u+variant]{\ocamlinlinecode{polymorphic\_\allowbreak{}variant}} ]}\\
\label{container-page-test+u+package+++ml-module-Type-type-exact+u+object}\ocamlcodefragment{\ocamltag{keyword}{type} 'a exact\_\allowbreak{}object = \ocamltag{type-var}{'a} \ocamltag{keyword}{constraint} \ocamltag{type-var}{'a} = < a : int;\allowbreak{} b : int;\allowbreak{} >}\\
\label{container-page-test+u+package+++ml-module-Type-type-lower+u+object}\ocamlcodefragment{\ocamltag{keyword}{type} 'a lower\_\allowbreak{}object = \ocamltag{type-var}{'a} \ocamltag{keyword}{constraint} \ocamltag{type-var}{'a} = < a : int;\allowbreak{} b : int;\allowbreak{} .\allowbreak{}.\allowbreak{} >}\\
\label{container-page-test+u+package+++ml-module-Type-type-poly+u+object}\ocamlcodefragment{\ocamltag{keyword}{type} 'a poly\_\allowbreak{}object = \ocamltag{type-var}{'a} \ocamltag{keyword}{constraint} \ocamltag{type-var}{'a} = < a : a.\allowbreak{} \ocamltag{type-var}{'a};\allowbreak{} >}\\
\label{container-page-test+u+package+++ml-module-Type-type-double+u+constrained}\ocamlcodefragment{\ocamltag{keyword}{type} ('a,\allowbreak{} 'b) double\_\allowbreak{}constrained = \ocamltag{type-var}{'a} * \ocamltag{type-var}{'b} \ocamltag{keyword}{constraint} \ocamltag{type-var}{'a} = int \ocamltag{keyword}{constraint} \ocamltag{type-var}{'b} = unit}\\
\label{container-page-test+u+package+++ml-module-Type-type-as+u+}\ocamlcodefragment{\ocamltag{keyword}{type} as\_\allowbreak{} = int \ocamltag{keyword}{as} 'a * \ocamltag{type-var}{'a}}\\
\label{container-page-test+u+package+++ml-module-Type-type-extensible}\ocamlcodefragment{\ocamltag{keyword}{type} extensible = .\allowbreak{}.\allowbreak{}}\\
\ocamlcodefragment{\ocamltag{keyword}{type} \hyperref[container-page-test+u+package+++ml-module-Type-type-extensible]{\ocamlinlinecode{extensible}} += }\\
\begin{ocamltabular}{p{0.500\textwidth}p{0.500\textwidth}}\ocamlcodefragment{| \ocamltag{extension}{Extension}}\label{container-page-test+u+package+++ml-module-Type-extension-Extension}& Documentation for \hyperref[container-page-test+u+package+++ml-module-Type-extension-Extension]{\ocamlinlinecode{\ocamlinlinecode{Extension}}[p\pageref*{container-page-test+u+package+++ml-module-Type-extension-Extension}]}.\\
\ocamlcodefragment{| \ocamltag{extension}{Another\_\allowbreak{}extension}}\label{container-page-test+u+package+++ml-module-Type-extension-Another+u+extension}& Documentation for \hyperref[container-page-test+u+package+++ml-module-Type-extension-Another+u+extension]{\ocamlinlinecode{\ocamlinlinecode{Another\_\allowbreak{}extension}}[p\pageref*{container-page-test+u+package+++ml-module-Type-extension-Another+u+extension}]}.\\
\end{ocamltabular}%
\\
\label{container-page-test+u+package+++ml-module-Type-type-mutually}\ocamlcodefragment{\ocamltag{keyword}{type} mutually = }\\
\begin{ocamltabular}{p{1.000\textwidth}}\ocamlcodefragment{| \ocamltag{constructor}{A} \ocamltag{keyword}{of} \hyperref[container-page-test+u+package+++ml-module-Type-type-recursive]{\ocamlinlinecode{recursive}}}\label{container-page-test+u+package+++ml-module-Type-type-mutually.A}\\
\end{ocamltabular}%
\\
\label{container-page-test+u+package+++ml-module-Type-type-recursive}\ocamlcodefragment{\ocamltag{keyword}{and} recursive = }\\
\begin{ocamltabular}{p{1.000\textwidth}}\ocamlcodefragment{| \ocamltag{constructor}{B} \ocamltag{keyword}{of} \hyperref[container-page-test+u+package+++ml-module-Type-type-mutually]{\ocamlinlinecode{mutually}}}\label{container-page-test+u+package+++ml-module-Type-type-recursive.B}\\
\end{ocamltabular}%
\\
\label{container-page-test+u+package+++ml-module-Type-exception-Foo}\ocamlcodefragment{\ocamltag{keyword}{exception} \ocamltag{exception}{Foo} \ocamltag{keyword}{of} int * int}\\


